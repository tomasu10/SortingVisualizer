{"version":3,"sources":["constants.js","sortingAlgorithms/mergeSort.js","sortingAlgorithms/bubbleSort.js","sortingAlgorithms/quickSort.js","sortingAlgorithms/selectionSort.js","animationHandlers/mergeSortAnimationHandler.js","animationHandlers/quickSortAnimationHandler.js","animationHandlers/selectionSortAnimationHandler.js","animationHandlers/bubbleSortAnimationHandler.js","SortingVisualizer/SortingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["constants","ADDED_DELAY","PRIMARY_COLOR","SECONDARY_COLOR","TERTIARY_COLOR","SUCCESS_COLOR","getMergeSortAnimations","array","animations","length","auxiliaryArray","slice","mergeSortHelper","mainArray","startIdx","endIdx","middleIdx","Math","floor","k","i","j","push","doMerge","getBubbleSortAnimations","noSwaps","content","swap","content1","content2","bubbleSort","idx1","idx2","temp","getQuickSortAnimations","quickSort","arr","left","right","pivotIndex","pivot","start","end","pivotElement","swapIdx","pivotIdx","getSelectionSortAnimations","lowest","lowVal","selectionSort","mergeSortAnimationHandler","arrayBars","animationSpeed","barOneIdx","barTwoIdx","barOneStyle","style","barTwoStyle","color","setTimeout","backgroundColor","newHeight","height","quickSortAnimationHandler","toSecondaryColor","pivotStyle","newHeight1","newHeight2","selectionSortAnimationHandler","toTertiaryColor","tempBackgroundColor","color1","color2","bubbleSortAnimationHandler","SortingVisualizer","state","numOfArrayBars","handleChange","bind","handleSubmit","this","resetArray","document","getElementsByClassName","randomIntFromInterval","setState","event","target","name","preventDefault","size","parseInt","value","speed","sortingElements","disabled","algorithmAnimations","animationsHandler","disableSortingButtons","finishedSort","restoreSortingButtons","javaScriptSortedArray","sort","a","b","mergeSortedArray","console","log","arraysAreEqual","className","map","idx","key","onClick","onSubmit","htmlFor","id","type","min","max","step","onChange","React","Component","random","arrayOne","arrayTwo","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.daf3137c.chunk.js","sourcesContent":["const constants =  {\r\n    //Additional delay\r\n    ADDED_DELAY : 100,\r\n\r\n    // This is the main color of the array bars.\r\n    PRIMARY_COLOR : 'turquoise',\r\n\r\n    // This is the color of array bars that are being compared throughout the animations.\r\n    SECONDARY_COLOR :'red',\r\n\r\n    // This is the color of array bars for quickSort Pivot and lowest Value for selection Sort.\r\n    TERTIARY_COLOR:'yellow',\r\n\r\n    //This is the completed sort color\r\n    SUCCESS_COLOR : 'green'\r\n}\r\n\r\nexport default constants;","export function getMergeSortAnimations(array) {\r\n    const animations = [];\r\n    if (array.length <= 1) return array;\r\n    const auxiliaryArray = array.slice();\r\n    mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\r\n    return animations;\r\n  }\r\n  \r\n  function mergeSortHelper(\r\n    mainArray,\r\n    startIdx,\r\n    endIdx,\r\n    auxiliaryArray,\r\n    animations,\r\n  ) {\r\n    if (startIdx === endIdx) return;\r\n    const middleIdx = Math.floor((startIdx + endIdx) / 2);\r\n    mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\r\n    mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\r\n    doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\r\n  }\r\n  \r\n  function doMerge(\r\n    mainArray,\r\n    startIdx,\r\n    middleIdx,\r\n    endIdx,\r\n    auxiliaryArray,\r\n    animations,\r\n  ) {\r\n    let k = startIdx;\r\n    let i = startIdx;\r\n    let j = middleIdx + 1;\r\n    while (i <= middleIdx && j <= endIdx) {\r\n      // These are the values that we're comparing; we push them once\r\n      // to change their color.\r\n      animations.push([i, j]);\r\n      // These are the values that we're comparing; we push them a second\r\n      // time to revert their color.\r\n      animations.push([i, j]);\r\n      if (auxiliaryArray[i] <= auxiliaryArray[j]) {\r\n        // We overwrite the value at index k in the original array with the\r\n        // value at index i in the auxiliary array.\r\n        animations.push([k, auxiliaryArray[i]]);\r\n        mainArray[k++] = auxiliaryArray[i++];\r\n      } else {\r\n        // We overwrite the value at index k in the original array with the\r\n        // value at index j in the auxiliary array.\r\n        animations.push([k, auxiliaryArray[j]]);\r\n        mainArray[k++] = auxiliaryArray[j++];\r\n      }\r\n    }\r\n    while (i <= middleIdx) {\r\n      // These are the values that we're comparing; we push them once\r\n      // to change their color.\r\n      animations.push([i, i]);\r\n      // These are the values that we're comparing; we push them a second\r\n      // time to revert their color.\r\n      animations.push([i, i]);\r\n      // We overwrite the value at index k in the original array with the\r\n      // value at index i in the auxiliary array.\r\n      animations.push([k, auxiliaryArray[i]]);\r\n      mainArray[k++] = auxiliaryArray[i++];\r\n    }\r\n    while (j <= endIdx) {\r\n      // These are the values that we're comparing; we push them once\r\n      // to change their color.\r\n      animations.push([j, j]);\r\n      // These are the values that we're comparing; we push them a second\r\n      // time to revert their color.\r\n      animations.push([j, j]);\r\n      // We overwrite the value at index k in the original array with the\r\n      // value at index j in the auxiliary array.\r\n      animations.push([k, auxiliaryArray[j]]);\r\n      mainArray[k++] = auxiliaryArray[j++];\r\n    }\r\n  }","export function getBubbleSortAnimations(array) {\r\n    const animations = [];\r\n    bubbleSort(array, 0, array.length, animations);\r\n    return animations;\r\n  }\r\n\r\n\r\n  function bubbleSort(mainArray,\r\n    startIdx,\r\n    endIdx,\r\n    animations){\r\n        let noSwaps;\r\n\r\n        for(let i = endIdx; i > startIdx; i--){\r\n          noSwaps = true;\r\n            \r\n          for(let j = startIdx; j < i - 1; j++){\r\n            // These are the values you are comparing. You choose them once to change the color. No swap has occurred\r\n            animations.push({content:[j,j+1],swap:false});\r\n            // Check if current value is greater than next\r\n            if(mainArray[j] > mainArray[j+1]){\r\n                // Swap current value with next\r\n                swap(mainArray,j,j+1);   \r\n                //These are the values that you will be swapping. Include both the index and height. Swap has occurred\r\n                animations.push({content1:[j,mainArray[j]],content2:[j+1,mainArray[j+1]],swap:true});\r\n                noSwaps = false; \r\n            }\r\n            //Compared values are pushed again to animations to change color back to original\r\n            animations.push({content:[j,j+1],swap:false});\r\n           \r\n           \r\n          }\r\n          //If no swaps were completed, array is sorted. Break out of loops\r\n          if(noSwaps) break;\r\n        }\r\n        return;\r\n    }\r\n    //Swap function \r\n    function swap(array,idx1,idx2){\r\n        const temp = array[idx1];\r\n        array[idx1] = array[idx2];\r\n        array[idx2] = temp;\r\n    }\r\n","\r\nexport function getQuickSortAnimations(array) {\r\n    const animations = [];\r\n    quickSort(array, 0, array.length-1, animations);\r\n    return animations;\r\n  }\r\n\r\n\r\n function pivot(arr, start = 0, end = arr.length - 1,animations) {\r\n   //Push Pivot to animations to change to tertiary color\r\n    animations.push({content: end, swap:false,pivotElement:true});\r\n    //Set pivot to last value in arr\r\n    let pivot = arr[end];\r\n    //Start your swapIdx at the beginning of the array\r\n    let swapIdx = start;\r\n    //Iterate through array\r\n    for (let i = start; i < end; i++) {\r\n        //Save swapIdx to temp variable in order to set bar color back to primary\r\n        const temp = swapIdx;\r\n        // Push potential swap indices to animations to set secondary color. Push pivotIdx in animations  in order to prevent change of pivot color\r\n        animations.push({content:[i,swapIdx],swap:false,pivotElement:false,pivotIdx: end});\r\n      if (pivot > arr[i]) {\r\n        //Swap indices swapIdx and i when pivot is greater than arr[i]\r\n        //This will facilitate placing all values less than pivot are to its left and all values greater than pivot are to its right\r\n         swap(arr, swapIdx, i);\r\n         // Push desired swap indices and corresponding values to animations to swap the bar heights\r\n         animations.push({content1:[i,arr[i]],content2:[swapIdx,arr[swapIdx]],swap:true,pivotElement:false,pivotIdx: end})\r\n         // Increment swapIdx after swap so swap happens between past value and current value\r\n         swapIdx++;  \r\n      }\r\n      // Push swap indices to animations to revert back to primary color. Push pivotIdx in animations  in order to prevent change of pivot color\r\n      animations.push({content:[i,temp],swap:false,pivotElement:false,pivotIdx:end});\r\n\r\n    }\r\n    ////Push Pivot to animations to revert back to primary color\r\n    animations.push({content: end, swap:false,pivotElement:true});\r\n\r\n    /**\r\n     * Final Pivot Swap. This will swap pivot with swapIdx so all values less than pivot are to its left and all values greater than pivot are to its right\r\n     */\r\n    //Push pivot(end) and swapIdx to animations to change to secondary colors;\r\n    animations.push({content:[end,swapIdx],swap:false,pivotElement:false,pivotIdx: null});\r\n    //Swap pivot(end) and swapIdx\r\n    swap(arr, end, swapIdx);\r\n    // Push desired swap indices and corresponding values to animations to swap the bar heights\r\n    animations.push({content1:[end,arr[end]],content2:[swapIdx,arr[swapIdx]],swap:true,pivotElement:false,pivotIdx: null});\r\n    // Push swap indices to animations to revert back to primary color. \r\n    animations.push({content:[end,swapIdx],swap:false,pivotElement:false,pivotIdx: null});\r\n    return swapIdx;\r\n  }\r\n  \r\n  \r\n  function quickSort(arr, left = 0, right = arr.length -1,animations){\r\n      if(left < right){\r\n          let pivotIndex = pivot(arr, left, right,animations);\r\n          //left\r\n          quickSort(arr,left,pivotIndex-1,animations);\r\n          //right\r\n           quickSort(arr,pivotIndex+1,right,animations);\r\n        }\r\n       return;\r\n  } \r\n\r\n  function swap(arr, idx1, idx2){\r\n    const temp = arr[idx1];\r\n    arr[idx1] = arr[idx2];\r\n    arr[idx2] = temp;\r\n  }","export function getSelectionSortAnimations(array) {\r\n    const animations = [];\r\n    selectionSort(array, 0, array.length, animations);\r\n    return animations;\r\n  }\r\n\r\n\r\n  function selectionSort(mainArray,\r\n    startIdx,\r\n    endIdx,\r\n    animations){\r\n        for(let i = 0; i < mainArray.length; i++){\r\n            let lowest = i;\r\n            for(let j = i+1; j < mainArray.length; j++){\r\n                const temp = lowest;\r\n                //Push comparisons to animations array to change color\r\n                animations.push({content:[j,lowest],swap:false,lowVal:lowest});\r\n                if(mainArray[j] < mainArray[lowest]){\r\n                    lowest = j;\r\n                }\r\n                //temp acts a temporary variable for lowest within nested loop \r\n                //Push comparions to animations again to revert back to original color\r\n                animations.push({content:[j,temp],swap:false,lowVal:temp});\r\n            }\r\n\r\n            if(i !== lowest){\r\n                //SWAP!\r\n                //Push swap indices to animations to change color of bars to be swapped\r\n                animations.push({content:[i,lowest],swap:false,lowVal:null});\r\n                swap(mainArray,i,lowest);\r\n                //Push new indices along with their values(height) in order to facilitate swap\r\n                animations.push({content1:[i,mainArray[i]],content2:[lowest,mainArray[lowest]],swap:true,lowVal:null});\r\n                //Push Swap indices to animations to revert back to original color\r\n                animations.push({content:[i,lowest],swap:false,lowVal:null});\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    //Swap function \r\n    function swap(array,idx1,idx2){\r\n        const temp = array[idx1];\r\n        array[idx1] = array[idx2];\r\n        array[idx2] = temp;\r\n    }\r\n","import constants from '../constants'\r\nexport function mergeSortAnimationHandler(animations,arrayBars,animationSpeed){\r\n    for (let i = 0; i < animations.length; i++) {\r\n      //Identify if color change is needed (Color changes 2 out of every 3 animations i.e animations[0],animations[1],animations[3]...)\r\n        const isColorChange = i % 3 !== 2;\r\n        if (isColorChange) {\r\n          //Store the index of each bar (barOneIdx and barTwoIdx).\r\n          const [barOneIdx, barTwoIdx] = animations[i];\r\n          const barOneStyle = arrayBars[barOneIdx].style;\r\n          const barTwoStyle = arrayBars[barTwoIdx].style;\r\n          //Colors change to secondary color on the beginning of each triplet (i.e animaitons[0], animations[3]... )\r\n          const color = i % 3 === 0 ? constants.SECONDARY_COLOR : constants.PRIMARY_COLOR;\r\n          setTimeout(() => {\r\n            //Chage color of array bars\r\n            barOneStyle.backgroundColor = color;\r\n            barTwoStyle.backgroundColor = color;\r\n          }, i * animationSpeed);\r\n        } else {\r\n          setTimeout(() => {\r\n            //On every third animation (i.e. animation[2]), height of corresponding array bar is updated to match algorithm merging\r\n            const [barOneIdx, newHeight] = animations[i];\r\n            const barOneStyle = arrayBars[barOneIdx].style;\r\n            barOneStyle.height = `${newHeight}px`;\r\n          }, i * animationSpeed);\r\n        }\r\n      }\r\n}","import constants from '../constants';\r\nexport function quickSortAnimationHandler(animations,arrayBars,animationSpeed){\r\n    //Variable keeps track of color swaps\r\n    let toSecondaryColor = true;\r\n    let toTertiaryColor = true;\r\n    for (let i = 0; i < animations.length; i++) {\r\n      if (animations[i].pivotElement) {\r\n        const pivot = animations[i].content;\r\n        const pivotStyle = arrayBars[pivot].style;\r\n        //Toggle Tertiary color. \r\n        const color = toTertiaryColor ? constants.TERTIARY_COLOR : constants.PRIMARY_COLOR;\r\n        setTimeout(() => {\r\n          pivotStyle.backgroundColor = color;\r\n        }, i * animationSpeed);\r\n      }\r\n      else{\r\n      //Check to see if the animation encompasses a swap\r\n        if (!animations[i].swap) {\r\n          //No swap made\r\n          // Select bars which are being compared\r\n          const [barOneIdx, barTwoIdx] = animations[i].content;\r\n          // console.log(`BarOne: ${barOneIdx} BarTwo: ${barTwoIdx}`);\r\n          const barOneStyle = arrayBars[barOneIdx].style;\r\n          const barTwoStyle = arrayBars[barTwoIdx].style;\r\n          //Change colors of bars depending on the previous color\r\n          const color = toSecondaryColor ? constants.SECONDARY_COLOR : constants.PRIMARY_COLOR;\r\n          toSecondaryColor = toSecondaryColor ? false : true;\r\n          //Change color of compared bars on a timer\r\n          setTimeout(() => {\r\n            if(barOneIdx !== animations[i].pivotIdx)\r\n            barOneStyle.backgroundColor = color;\r\n            if(barTwoIdx !== animations[i].pivotIdx)\r\n            barTwoStyle.backgroundColor = color;\r\n          }, i * animationSpeed);\r\n        } \r\n        else {\r\n          //Swap Made\r\n          toSecondaryColor = false;\r\n          //Change bar height according to swaps made\r\n          setTimeout(() => {\r\n                const [barOneIdx, newHeight1] = animations[i].content1;\r\n                const barOneStyle = arrayBars[barOneIdx].style;\r\n                barOneStyle.height = `${newHeight1}px`;\r\n                const [barTwoIdx, newHeight2] = animations[i].content2;\r\n                const barTwoStyle = arrayBars[barTwoIdx].style;\r\n                barTwoStyle.height = `${newHeight2}px`;\r\n            }, i * animationSpeed);\r\n        }\r\n        }\r\n    }\r\n}","import constants from '../constants';\r\n\r\nexport function selectionSortAnimationHandler(animations,arrayBars,animationSpeed){\r\n    let toSecondaryColor = true;\r\n    let toTertiaryColor = true;\r\n    for (let i = 0; i < animations.length; i++) {\r\n      //Check to see if the animation encompasses a swap\r\n      if (!animations[i].swap) {\r\n        //No swap made\r\n        // Select bars which are being compared\r\n        const [barOneIdx, barTwoIdx] = animations[i].content;\r\n        const barOneStyle = arrayBars[barOneIdx].style;\r\n        const barTwoStyle = arrayBars[barTwoIdx].style;\r\n        //Change colors of bars depending on the previous color. Find lowest value and change\r\n        const color1 = toSecondaryColor ? constants.SECONDARY_COLOR : constants.PRIMARY_COLOR;\r\n        const color2 = toTertiaryColor ? constants.TERTIARY_COLOR : constants.PRIMARY_COLOR;\r\n        toSecondaryColor = toSecondaryColor ? false : true;\r\n        toTertiaryColor = toTertiaryColor ? false : true;\r\n        //Change color of compared bars on a timer\r\n        setTimeout(() => {\r\n          barOneStyle.backgroundColor = color1;\r\n          barTwoStyle.backgroundColor = color2;\r\n        }, i * animationSpeed);\r\n      } else {\r\n        //Swap Made\r\n        toSecondaryColor = false;\r\n        toTertiaryColor = false;\r\n        //Change bar height according to swaps made\r\n        setTimeout(() => {\r\n          const [barOneIdx, newHeight1] = animations[i].content1;\r\n          const barOneStyle = arrayBars[barOneIdx].style;\r\n          barOneStyle.height = `${newHeight1}px`;\r\n          const [barTwoIdx, newHeight2] = animations[i].content2;\r\n          const barTwoStyle = arrayBars[barTwoIdx].style;\r\n          barTwoStyle.height = `${newHeight2}px`;\r\n          const tempBackgroundColor = barOneStyle.backgroundColor;\r\n          barOneStyle.backgroundColor = barTwoStyle.backgroundColor;\r\n          barTwoStyle.backgroundColor = tempBackgroundColor;\r\n        }, i * animationSpeed);\r\n      }\r\n    } \r\n\r\n}","import constants from  '../constants';\r\n\r\nexport function bubbleSortAnimationHandler(animations,arrayBars,animationSpeed){\r\n    //Variable keeps track of color swaps\r\n    let toSecondaryColor = true;\r\n    for (let i = 0; i < animations.length; i++) {\r\n      //Check to see if the animation encompasses a swap\r\n      if (!animations[i].swap) {\r\n        //No swap made\r\n        // Select bars which are being compared\r\n        const [barOneIdx, barTwoIdx] = animations[i].content;\r\n        const barOneStyle = arrayBars[barOneIdx].style;\r\n        const barTwoStyle = arrayBars[barTwoIdx].style;\r\n        //Change colors of bars depending on the previous color\r\n        const color = toSecondaryColor ? constants.SECONDARY_COLOR : constants.PRIMARY_COLOR;\r\n        toSecondaryColor = toSecondaryColor ? false : true;\r\n        //Change color of compared bars on a timer\r\n        setTimeout(() => {\r\n          barOneStyle.backgroundColor = color;\r\n          barTwoStyle.backgroundColor = color;\r\n        }, i * animationSpeed);\r\n      } else {\r\n        //Swap Made\r\n        toSecondaryColor = false;\r\n        //Change bar height according to swaps made\r\n        setTimeout(() => {\r\n          const [barOneIdx, newHeight1] = animations[i].content1;\r\n          const barOneStyle = arrayBars[barOneIdx].style;\r\n          barOneStyle.height = `${newHeight1}px`;\r\n          const [barTwoIdx, newHeight2] = animations[i].content2;\r\n          const barTwoStyle = arrayBars[barTwoIdx].style;\r\n          barTwoStyle.height = `${newHeight2}px`;\r\n        }, i * animationSpeed);\r\n\r\n      }\r\n    }\r\n}","import React from 'react';\r\nimport constants from '../constants'\r\nimport { getMergeSortAnimations } from '../sortingAlgorithms/mergeSort.js';\r\nimport { getBubbleSortAnimations } from '../sortingAlgorithms/bubbleSort.js';\r\nimport { getQuickSortAnimations } from '../sortingAlgorithms/quickSort.js';\r\nimport { getSelectionSortAnimations } from '../sortingAlgorithms/selectionSort.js';\r\nimport { mergeSortAnimationHandler } from '../animationHandlers/mergeSortAnimationHandler.js';\r\nimport { quickSortAnimationHandler } from '../animationHandlers/quickSortAnimationHandler.js';\r\nimport { selectionSortAnimationHandler } from '../animationHandlers/selectionSortAnimationHandler.js';\r\nimport { bubbleSortAnimationHandler } from '../animationHandlers/bubbleSortAnimationHandler.js';\r\nimport './SortingVisualizer.css';\r\n\r\n\r\n\r\nexport default class SortingVisualizer extends React.Component {\r\n  constructor() {\r\n    super();\r\n\r\n    this.state = {\r\n      array: [],\r\n      numOfArrayBars: 100,\r\n      animationSpeed : 3\r\n    };\r\n    this.handleChange = this.handleChange.bind(this);\r\n    this.handleSubmit = this.handleSubmit.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.resetArray();\r\n  }\r\n\r\n  resetArray() {\r\n    const array = [];\r\n    // Set all array bars back to primary color after sorting\r\n    if(this.state.array){\r\n      const arrayBars = document.getElementsByClassName('array-bar');\r\n      for(let i =0 ;i<arrayBars.length;i++){\r\n        arrayBars[i].style.backgroundColor = constants.PRIMARY_COLOR;\r\n      }\r\n    }\r\n    //Create new array bars with height of 5-500px\r\n    for (let i = 0; i < this.state.numOfArrayBars; i++) {\r\n      array.push(randomIntFromInterval(5, 500));\r\n    }\r\n   this.setState({ array });\r\n  }\r\n\r\n  handleSubmit(event){\r\n    //Reset Array if size is changed. Do not reset array if speed is changed\r\n    if(event.target.name === 'size-submit'){\r\n      this.resetArray();\r\n    }\r\n    event.preventDefault();\r\n  }\r\n\r\n  handleChange(event) {\r\n    //Change the value of numArrayBars/animationSpeed as the user types\r\n    if(event.target.name === 'array-size'){\r\n      let size = parseInt(event.target.value);\r\n      this.setState({numOfArrayBars: size});\r\n    }\r\n    else if (event.target.name === 'array-speed'){\r\n      let speed = parseInt(event.target.value);\r\n      this.setState({animationSpeed:speed});\r\n    }\r\n    \r\n  }\r\n\r\n    disableSortingButtons(){\r\n      //Select all buttons and set disabled property to true\r\n      const sortingElements = document.getElementsByClassName('sorting');\r\n      for(const element of sortingElements){\r\n        element.disabled = true;\r\n      }\r\n    }\r\n\r\n    restoreSortingButtons(animationSpeed,length){\r\n      //Select all buttons and set disabled property to false once sorting is complete\r\n      const sortingElements = document.getElementsByClassName('sorting');\r\n      setTimeout(()=>{\r\n        for(const element of sortingElements){\r\n          element.disabled = false;\r\n        }\r\n      },animationSpeed*length+constants.ADDED_DELAY);\r\n    }\r\n\r\n  sort(algorithmAnimations, animationsHandler){\r\n    // Create DOM animations that correspond to sorting algorithm\r\n    const animations = algorithmAnimations(this.state.array);\r\n    //Save length of animations array and speed to determine how long alogrithm will take (length * speed)\r\n    const size = animations.length;\r\n    const speed = this.state.animationSpeed;\r\n    //Store all array bars from DOM\r\n    const arrayBars = document.getElementsByClassName('array-bar');\r\n    //Disable all Buttons on DOM\r\n    this.disableSortingButtons();\r\n    //Display animations on DOM\r\n    animationsHandler(animations,arrayBars,speed);\r\n    //Set all array bars to green after sort is complete\r\n    finishedSort(size,arrayBars,speed);\r\n    //Restore all Buttons on DOM\r\n    this.restoreSortingButtons(speed,size);\r\n  }\r\n\r\n  // NOTE: This method will only work if your sorting algorithms actually return\r\n  // the sorted arrays; if they return the animations (as they currently do), then\r\n  // this method will be broken.\r\n  testSortingAlgorithms() {\r\n    for (let i = 0; i < 100; i++) {\r\n      const array = [];\r\n      const length = randomIntFromInterval(1, 1000);\r\n      for (let i = 0; i < length; i++) {\r\n        array.push(randomIntFromInterval(-1000, 1000));\r\n      }\r\n      const javaScriptSortedArray = array.slice().sort((a, b) => a - b);\r\n      const mergeSortedArray = getQuickSortAnimations(array.slice());\r\n      console.log(arraysAreEqual(javaScriptSortedArray, mergeSortedArray));\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const { array } = this.state;\r\n    return (\r\n      <div className=\"array-container\">\r\n        <h1>Sorting Algorithm Visualizer <i className=\"fas fa-sort-amount-up\"></i></h1>\r\n        {array.map((value, idx) => (\r\n          <div\r\n            className=\"array-bar\"\r\n            key={idx}\r\n            style={{\r\n              backgroundColor: constants.PRIMARY_COLOR,\r\n              height: `${value}px`,\r\n            }}></div>\r\n        ))}\r\n        <div>\r\n          <button className = 'array-buttons sorting'  onClick={() => this.resetArray()}>Generate New Array</button>\r\n          <button className = 'array-buttons sorting'  onClick={() => this.sort(getMergeSortAnimations,mergeSortAnimationHandler)}>Merge Sort</button>\r\n          <button className = 'array-buttons sorting'  onClick={() => this.sort(getQuickSortAnimations,quickSortAnimationHandler)}>Quick Sort</button>\r\n          <button className = 'array-buttons sorting'  onClick={() => this.sort(getSelectionSortAnimations,selectionSortAnimationHandler)}>Selection Sort</button>\r\n          <button className = 'array-buttons sorting'  onClick={() => this.sort(getBubbleSortAnimations,bubbleSortAnimationHandler)}>Bubble Sort</button>\r\n          {/* <button className = 'array-buttons' disabled = {this.state.waitForClick} onClick={() => this.testSortingAlgorithms()}>\r\n            Test Sorting Algorithms\r\n          </button> */}\r\n        </div>\r\n        <div className= 'array-sizes'>\r\n          <h4>Array Size:</h4>\r\n          <form name = 'size-submit' onSubmit={this.handleSubmit}>\r\n            <label htmlFor=\"array-size\"></label>\r\n            <input  name=\"array-size\" className = \"sorting\" id=\"array-size\" type=\"number\" value= {this.state.numOfArrayBars} min=\"2.00\" max = \"100.00\" step=\"1.00\" onChange={this.handleChange}></input>\r\n            <input className = \"sorting\" type=\"submit\" value=\"Submit\" />\r\n          </form>\r\n         \r\n        </div>\r\n        <div className = 'array-sorting-speeds'>\r\n          <h4>Sorting Speeds</h4>\r\n          <form name = 'speed-submit' onSubmit={this.handleSubmit}>\r\n            <label htmlFor=\"array-speed\"></label>\r\n            <input  name=\"array-speed\" className = \"sorting\" id=\"array-speed\" type=\"number\" value= {this.state.animationSpeed} min=\"1.00\" max = \"27.00\" step=\"1.00\" onChange={this.handleChange}></input>\r\n            <input className = \"sorting\" type=\"submit\" value=\"Submit\" />\r\n          </form>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n// From https://stackoverflow.com/questions/4959975/generate-random-number-between-two-numbers-in-javascript\r\nfunction randomIntFromInterval(min, max) {\r\n  // min and max included\r\n  return Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n//USED FOR TESTING\r\nfunction arraysAreEqual(arrayOne, arrayTwo) {\r\n  if (arrayOne.length !== arrayTwo.length) return false;\r\n  for (let i = 0; i < arrayOne.length; i++) {\r\n    if (arrayOne[i] !== arrayTwo[i]) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction finishedSort(length,arrayBars,animationSpeed){\r\n  setTimeout(() => {\r\n    for(let i =0 ;i<arrayBars.length;i++){\r\n      arrayBars[i].style.backgroundColor = constants.SUCCESS_COLOR;\r\n    }\r\n    //Delay until end of sorting plus additional delay to extend past the end of the sorting algorithms. \r\n  },(animationSpeed *length)+constants.ADDED_DELAY);\r\n}","\nimport React from 'react';\nimport SortingVisualizer from './SortingVisualizer/SortingVisualizer.jsx';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SortingVisualizer></SortingVisualizer>\n    </div>\n  );\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}